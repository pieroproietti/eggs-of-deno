// src/classes/ovary.d/filesystem.ts
import { IEggsConfig } from "../settings.ts";
import { Constants } from "../constants.ts";
import { Utils } from "../utils.ts";
import { IDistroInfo } from "../distro.ts";
import { path, ensureDir, exists } from "../../deps.ts";

export class FileSystem {
  private config: IEggsConfig;
  private distro: IDistroInfo;
  
  // Script recorder
  private bindScript: string[] = [];
  private unbindScript: string[] = [];
  
  // Paths cache
  private dirs: {
    merged: string;
    lower: string;
    upper: string;
    work: string;
  };

  constructor(config: IEggsConfig, distro: IDistroInfo) {
    this.config = config;
    this.distro = distro;

    // Definiamo le directory di lavoro dell'Overlay
    const workRoot = path.join(Constants.NEST, ".mnt");
    this.dirs = {
        merged: workRoot,
        lower: path.join(Constants.NEST, ".lower"),
        upper: path.join(Constants.NEST, ".upper"),
        work: path.join(Constants.NEST, ".work")
    };
  }

  /**
   * Esegue il binding del filesystem (Motore OverlayFS)
   */
  async bind(options: any) {
    Utils.title("üîó Binding Live Filesystem (OverlayFS)");
    
    // Header script
    this.bindScript.push("#!/bin/bash", "# Auto-generated by Eggs Deno", "");

    // 1. Preparazione Cartelle Base
    await this.ensureBaseDirs();

    // 2. Scansione Root (/)
    for await (const entry of Deno.readDir("/")) {
        const name = entry.name;
        const hostPath = `/${name}`;
        
        // Saltiamo cartelle speciali che gestiamo diversamente o ignoriamo
        if (["proc", "sys", "dev", "run", "tmp", "mnt", "media", "cdrom", "lost+found"].includes(name)) {
            // Creiamo solo il mountpoint vuoto nella destinazione
            await this.execBind(`mkdir -p ${this.dirs.merged}/${name}`);
            continue;
        }

        // Saltiamo la nostra stessa cartella di lavoro per evitare loop infiniti
        // (Es. se /home/eggs √® in root)
        if (hostPath === Constants.NEST) continue;

        const stat = await Deno.lstat(hostPath);

        if (stat.isSymlink) {
            // --- SYMLINK ---
            const target = await Deno.readLink(hostPath);
            // Ricreiamo il link nel merged
            await this.execBind(`ln -sf ${target} ${this.dirs.merged}/${name}`);
        
        } else if (stat.isDirectory) {
            // --- DIRECTORY ---
            if (this.isOverlayCandidate(name)) {
                // CASO 1: Overlay (RW) - es. /etc, /usr, /var
                await this.mountOverlay(name);
            } else if (this.isCopyCandidate(name)) {
                // CASO 2: Copia Pura - es. /root (se richiesto)
                await this.execBind(`cp -ax ${hostPath} ${this.dirs.merged}/`);
            } else {
                // CASO 3: Bind Read-Only standard
                await this.mountBindRo(name);
            }

        } else if (stat.isFile) {
            // --- FILE ---
            // Copiamo i file sciolti nella root (es. .autorelabel)
            await this.execBind(`cp -p ${hostPath} ${this.dirs.merged}/`);
        }
    }

    // 3. FIX USR MERGE (Critico per Debian 12+)
    await this.applyUsrMergeFix();

    // 4. Salvataggio script di debug
    await this.saveScripts();
  }

  /**
   * Smonta tutto (Unbind)
   */
  async unbind() {
    Utils.title("üîå Unbinding Filesystem");
    
    // Logica inversa semplificata: smontiamo il merged
    // In produzione dovremmo leggere /proc/mounts per essere sicuri
    const mountPoint = this.dirs.merged;
    
    // Generiamo script unbind (questo √® un approccio brutale ma efficace per ora)
    const cmd = `umount -R ${mountPoint}`;
    console.log(cmd);
    // await Utils.run("umount", ["-R", mountPoint]);
    
    // Pulizia cartelle temp
    // await Deno.remove(this.dirs.lower, { recursive: true });
    // await Deno.remove(this.dirs.upper, { recursive: true });
    // await Deno.remove(this.dirs.work, { recursive: true });
  }

  // --- PRIVATE WORKERS ---

  private async ensureBaseDirs() {
    await ensureDir(this.dirs.merged);
    await ensureDir(this.dirs.lower);
    await ensureDir(this.dirs.upper);
    await ensureDir(this.dirs.work);
  }

  /**
   * Monta una directory in OverlayFS mode
   * (Permette modifiche senza toccare l'host)
   */
  private async mountOverlay(dirName: string) {
    const lower = path.join(this.dirs.lower, dirName);
    const upper = path.join(this.dirs.upper, dirName);
    const work = path.join(this.dirs.work, dirName);
    const merged = path.join(this.dirs.merged, dirName);

    this.bindScript.push(`# Overlay: /${dirName}`);

    // 1. Creiamo le dir di appoggio
    await this.execBind(`mkdir -p ${lower} ${upper} ${work} ${merged}`);

    // 2. Montiamo l'originale in Lower (Read Only)
    // mount --bind /etc .lower/etc
    await this.execBind(`mount --bind /${dirName} ${lower}`);
    // mount -o remount,ro,bind .lower/etc
    await this.execBind(`mount -o remount,ro,bind ${lower}`);

    // 3. Montiamo l'Overlay
    // mount -t overlay overlay -o lowerdir=...,upperdir=...,workdir=... merged
    const opts = `lowerdir=${lower},upperdir=${upper},workdir=${work}`;
    await this.execBind(`mount -t overlay overlay -o ${opts} ${merged}`);
  }

  /**
   * Monta una directory in Bind Read-Only mode
   */
  private async mountBindRo(dirName: string) {
    const target = path.join(this.dirs.merged, dirName);
    this.bindScript.push(`# Bind RO: /${dirName}`);
    
    await this.execBind(`mkdir -p ${target}`);
    await this.execBind(`mount --bind /${dirName} ${target}`);
    await this.execBind(`mount -o remount,ro,bind ${target}`);
  }

  /**
   * Esegue un comando e lo registra nello script
   */
  private async execBind(cmd: string) {
    this.bindScript.push(cmd);
    
    // Esecuzione reale:
    // Dividiamo la stringa comando in array per Deno.Command
    // Attenzione: questa √® una semplificazione, comandi complessi con quote richiedono un parser
    const parts = cmd.split(" ");
    const exe = parts[0];
    const args = parts.slice(1);

    // console.log(`[EXEC] ${cmd}`); // Verbose
    // await Utils.run(exe, args); // Decommenta per eseguire
  }

  /**
   * Fix per layout usr-merge (bin -> usr/bin)
   */
  private async applyUsrMergeFix() {
    this.bindScript.push("", "# USR MERGE FIX");
    const links = ["bin", "sbin", "lib", "lib64"];
    
    for (const link of links) {
        const target = path.join(this.dirs.merged, link);
        // Se √® una directory vera, la rimuoviamo (√® un errore di copia/rsync)
        await this.execBind(`rm -rf ${target}`);
        // Ricreiamo il link corretto
        await this.execBind(`ln -sf usr/${link} ${target}`);
    }
  }

  private async saveScripts() {
    const bindFile = path.join(Constants.NEST, "bind.sh");
    await Deno.writeTextFile(bindFile, this.bindScript.join("\n"));
    await Deno.chmod(bindFile, 0o755);
    console.log(`üìù Script bind generato: ${bindFile}`);
  }

  // --- LOGICA DI DECISIONE ---
  
  private isOverlayCandidate(dir: string): boolean {
    // Directory che devono essere scrivibili o modificabili nell'uovo
    const candidates = ["etc", "usr", "var", "opt", "srv", "home", "root"];
    return candidates.includes(dir);
  }

  private isCopyCandidate(dir: string): boolean {
    return false; // Per ora facciamo tutto con Overlay o Bind
  }
}