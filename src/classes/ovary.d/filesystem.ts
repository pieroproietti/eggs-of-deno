// src/classes/ovary.d/filesystem.ts
import { IEggsConfig } from "../settings.ts";
import { Constants } from "../constants.ts";
import { Utils } from "../utils.ts";
import { IDistroInfo } from "../distro.ts";
import { path, ensureDir, exists } from "../../deps.ts";

export class FileSystem {
  private config: IEggsConfig;
  private distro: IDistroInfo;
  
  // Script recorder
  private bindScript: string[] = [];
  private unbindScript: string[] = [];
  
  // Paths cache
  private dirs: {
    merged: string;
    lower: string;
    upper: string;
    work: string;
  };

  constructor(config: IEggsConfig, distro: IDistroInfo) {
    this.config = config;
    this.distro = distro;

    // Definiamo le directory di lavoro dell'Overlay
    const workRoot = path.join(Constants.NEST, ".mnt");
    this.dirs = {
        merged: workRoot,
        lower: path.join(Constants.NEST, ".lower"),
        upper: path.join(Constants.NEST, ".upper"),
        work: path.join(Constants.NEST, ".work")
    };
  }

  /**
   * Esegue il binding del filesystem (Motore OverlayFS)
   */
  async bind(options: any) {
    Utils.title("üîó Binding Live Filesystem (OverlayFS)");
    
    // Header script
    this.bindScript.push("#!/bin/bash", "# Auto-generated by egfs-of-deno", "");

    // 1. Preparazione Cartelle Base
    await this.ensureBaseDirs();

    // 2. Scansione Root (/)
    for await (const entry of Deno.readDir("/")) {
        const name = entry.name;
        const hostPath = `/${name}`;
        
        // Saltiamo cartelle speciali che gestiamo diversamente o ignoriamo
        if (["proc", "sys", "dev", "run", "tmp", "mnt", "media", "cdrom", "lost+found"].includes(name)) {
            // Creiamo solo il mountpoint vuoto nella destinazione
            await this.execBind(`mkdir -p ${this.dirs.merged}/${name}`);
            continue;
        }

        // Saltiamo la nostra stessa cartella di lavoro per evitare loop infiniti
        // (Es. se /home/eggs √® in root)
        if (hostPath === Constants.NEST) continue;

        const stat = await Deno.lstat(hostPath);

        if (stat.isSymlink) {
            // --- SYMLINK ---
            const target = await Deno.readLink(hostPath);
            // Ricreiamo il link nel merged
            await this.execBind(`ln -sf ${target} ${this.dirs.merged}/${name}`);
        
        } else if (stat.isDirectory) {
            // --- DIRECTORY ---
            if (this.isOverlayCandidate(name)) {
                // CASO 1: Overlay (RW) - es. /etc, /usr, /var
                await this.mountOverlay(name);
            } else if (this.isCopyCandidate(name)) {
                // CASO 2: Copia Pura - es. /root (se richiesto)
                await this.execBind(`cp -ax ${hostPath} ${this.dirs.merged}/`);
            } else {
                // CASO 3: Bind Read-Only standard
                await this.mountBindRo(name);
            }

        } else if (stat.isFile) {
            // --- FILE ---
            // Copiamo i file sciolti nella root (es. .autorelabel)
            await this.execBind(`cp -p ${hostPath} ${this.dirs.merged}/`);
        }
    }

    // 3. FIX USR MERGE (Critico per Debian 12+)
    await this.applyUsrMergeFix();

    // 4. Salvataggio script di debug
    await this.saveScripts();
  }

  /**
   * Smonta tutto (Unbind)
   */
  async unbind() {
    Utils.title("üîå Unbinding Filesystem");
    
    // 1. Unmount Merged (The consuming layer)
    // Logica inversa semplificata: smontiamo il merged
    await this.smartUnmount(this.dirs.merged, true);
    
    // 2. Unmount Lower (The backing layer)
    // IMPORTANT: umount -R on merged does NOT unmount the binding sources in .lower
    // because they are separate mount points. We must unmount them explicitly.
    // Otherwise Deno.remove() fails with EROFS (Read-only file system) because
    // it tries to delete files inside active read-only bind mounts.
    await this.cleanupMounts(this.dirs.lower);
    
    // 3. Pulizia cartelle temp
    if (await exists(this.dirs.lower)) await Deno.remove(this.dirs.lower, { recursive: true });
    if (await exists(this.dirs.upper)) await Deno.remove(this.dirs.upper, { recursive: true });
    if (await exists(this.dirs.work)) await Deno.remove(this.dirs.work, { recursive: true });
  }

  /**
   * Helper to unmount everything inside a directory by reading /proc/mounts.
   * Ensures that we don't try to rm -rf a directory containing active mounts.
   */
  private async cleanupMounts(prefix: string) {
    try {
        if (!await exists("/proc/mounts")) return;

        const content = await Deno.readTextFile("/proc/mounts");
        const mountPoints: string[] = [];
        
        for (const line of content.split("\n")) {
            const parts = line.split(" ");
            if (parts.length < 2) continue;
            const mp = parts[1];
            
            // Collect any mount point that resides inside our target prefix
            // (e.g. /home/eggs/.lower/etc)
            if (mp.startsWith(prefix)) {
                mountPoints.push(mp);
            }
        }
        
        // Sort cleanups: deepest paths first to handle nested mounts correctly
        mountPoints.sort((a, b) => b.length - a.length);
        
        if (mountPoints.length > 0) {
            console.log(`Found ${mountPoints.length} active mounts in ${prefix}. Cleaning up...`);
            for (const mp of mountPoints) {
                await this.smartUnmount(mp);
            }
        }
    } catch (e) {
        console.warn(`Warning during mount cleanup for ${prefix}: ${e}`);
    }
  }

  /**
   * Tries to unmount normally, falls back to lazy unmount on failure.
   */
  private async smartUnmount(mountPath: string, recursive = false) {
    const args = recursive ? ["-R", mountPath] : [mountPath];
    const cmdStr = `umount ${args.join(" ")}`;

    try {
        console.log(cmdStr);
        await Utils.run("umount", args);
    } catch (e) {
        console.warn(`Standard unmount failed for ${mountPath}: ${e}`);
        console.warn(`Attempting lazy unmount (umount -l)...`);
        
        const lazyArgs = recursive ? ["-l", "-R", mountPath] : ["-l", mountPath];
        try {
             await Utils.run("umount", lazyArgs);
             console.log(`Lazy unmount successful for ${mountPath}`);
        } catch (lazyErr) {
             console.error(`CRITICAL: Lazy unmount also failed for ${mountPath}: ${lazyErr}`);
             throw lazyErr;
        }
    }
  }

  // --- PRIVATE WORKERS ---

  private async ensureBaseDirs() {
    await ensureDir(this.dirs.merged);
    await ensureDir(this.dirs.lower);
    await ensureDir(this.dirs.upper);
    await ensureDir(this.dirs.work);
  }

  /**
   * Monta una directory in OverlayFS mode
   * (Permette modifiche senza toccare l'host)
   */
  private async mountOverlay(dirName: string) {
    const lower = path.join(this.dirs.lower, dirName);
    const upper = path.join(this.dirs.upper, dirName);
    const work = path.join(this.dirs.work, dirName);
    const merged = path.join(this.dirs.merged, dirName);

    this.bindScript.push(`# Overlay: /${dirName}`);

    // 1. Creiamo le dir di appoggio
    await this.execBind(`mkdir -p ${lower} ${upper} ${work} ${merged}`);

    // 2. Montiamo l'originale in Lower (Read Only)
    // mount --bind /etc .lower/etc
    await this.execBind(`mount --bind /${dirName} ${lower}`);
    // mount -o remount,ro,bind .lower/etc
    await this.execBind(`mount -o remount,ro,bind ${lower}`);

    // 3. Montiamo l'Overlay
    // mount -t overlay overlay -o lowerdir=...,upperdir=...,workdir=... merged
    const opts = `lowerdir=${lower},upperdir=${upper},workdir=${work}`;
    await this.execBind(`mount -t overlay overlay -o ${opts} ${merged}`);
  }

  /**
   * Monta una directory in Bind Read-Only mode
   */
  private async mountBindRo(dirName: string) {
    const target = path.join(this.dirs.merged, dirName);
    this.bindScript.push(`# Bind RO: /${dirName}`);
    
    await this.execBind(`mkdir -p ${target}`);
    await this.execBind(`mount --bind /${dirName} ${target}`);
    await this.execBind(`mount -o remount,ro,bind ${target}`);
  }

  /**
   * Esegue un comando e lo registra nello script
   */
  private async execBind(cmd: string) {
    this.bindScript.push(cmd);
    
    // Esecuzione reale:
    // Dividiamo la stringa comando in array per Deno.Command
    // Attenzione: questa √® una semplificazione, comandi complessi con quote richiedono un parser
    const parts = cmd.split(" ");
    const exe = parts[0];
    const args = parts.slice(1);

    console.log(`[EXEC] ${cmd}`); // Verbose
    await Utils.run(exe, args); // Decommenta per eseguire
  }

  /**
   * Fix per layout usr-merge (bin -> usr/bin)
   */
  private async applyUsrMergeFix() {
    this.bindScript.push("", "# USR MERGE FIX");
    const links = ["bin", "sbin", "lib", "lib64"];
    
    for (const link of links) {
        const target = path.join(this.dirs.merged, link);
        // Se √® una directory vera, la rimuoviamo (√® un errore di copia/rsync)
        await this.execBind(`rm -rf ${target}`);
        // Ricreiamo il link corretto
        await this.execBind(`ln -sf usr/${link} ${target}`);
    }
  }

  private async saveScripts() {
    const bindFile = path.join(Constants.NEST, "bind.sh");
    await Deno.writeTextFile(bindFile, this.bindScript.join("\n"));
    await Deno.chmod(bindFile, 0o755);
    console.log(`üìù Script bind generato: ${bindFile}`);
  }

  // --- LOGICA DI DECISIONE ---
  
  private isOverlayCandidate(dir: string): boolean {
    // Directory che devono essere scrivibili o modificabili nell'uovo
    const candidates = ["usr", "var", "opt", "srv", "home", "root"];
    return candidates.includes(dir);
  }

  private isCopyCandidate(dir: string): boolean {
    const candidates = ["etc"];
    return candidates.includes(dir);
  }
}